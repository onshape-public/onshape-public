<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Onshape Developer Documentation – Authentication</title><link>https://onshape-public.github.io/docs/auth/</link><description>Recent content in Authentication on Onshape Developer Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 May 2020 20:25:28 -0400</lastBuildDate><atom:link href="https://onshape-public.github.io/docs/auth/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: API Keys</title><link>https://onshape-public.github.io/docs/auth/apikeys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://onshape-public.github.io/docs/auth/apikeys/</guid><description>
&lt;h2 id="why-api-keys">Why API Keys?&lt;/h2>
&lt;p>API keys are useful for small applications meant for personal use, allowing developers to avoid the overhead of the OAuth workflow. Creating an app is very easy with API keys: create an API key with the Developer Portal, set up a function to build your API key header as in the samples, and make your API calls! There&amp;rsquo;s no need to deal with OAuth redirects or things like that.&lt;/p>
&lt;p>We&amp;rsquo;ve moved over to using API keys for authenticating requests instead of using cookies for several reasons.&lt;/p>
&lt;ol>
&lt;li>Security: Each request is signed with unique headers so that we can be sure it&amp;rsquo;s coming from the right place.&lt;/li>
&lt;li>OAuth: The API key system we&amp;rsquo;re now using for HTTP requests is the same process developers follow when building full-blown OAuth applications; there&amp;rsquo;s no longer a disconnect between the two.&lt;/li>
&lt;/ol>
&lt;p>Once you create an API key, it will only be valid in the stack on which it was created. An API key created on the partner stack, for example, will not function on the production stack.&lt;/p>
&lt;p>If you need information or have a question unanswered in this documentation, feel free to chat with us by sending an email to &lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a> or by checking out the &lt;a href="https://forum.onshape.com" target="_blank">forums&lt;/a>. If you are a member of the DevPartners group (see the Development help page for information) more detailed instructions and code examples are in the apikey sample repo.&lt;/p>
&lt;h2 id="create-api-keys">Create API Keys&lt;/h2>
&lt;ol>
&lt;li>Go to &lt;a href="https://dev-portal.onshape.com">https://dev-portal.onshape.com&lt;/a>.&lt;/li>
&lt;li>In the left pane, click &lt;code>API keys&lt;/code>.&lt;/li>
&lt;li>Click the &lt;code>Create new API key&lt;/code> button.&lt;/li>
&lt;li>Select the desired permissions for your app.&lt;/li>
&lt;li>Click the &lt;code>Create API key&lt;/code> button. &lt;/br>
&lt;img src="https://onshape-public.github.io/images/CreateNewAPIKey.png" alt="image">&lt;/li>
&lt;li>Copy both the &lt;strong>access key&lt;/strong> and &lt;strong>secret key&lt;/strong> from the pop-up window, save them somewhere, then click the &lt;code>Close&lt;/code> button.
&lt;/br>&lt;strong>IMPORTANT NOTE: You will not be able to find the secret key again, so save it somewhere safe!&lt;/strong>&lt;/br>
&lt;img src="https://onshape-public.github.io/images/APIKeySecretKey.png" alt="image">&lt;/li>
&lt;li>The details for your application appear. &lt;/br>
&lt;img src="https://onshape-public.github.io/images/DevPortalKeys.png" alt="image">&lt;/li>
&lt;li>Now that you have a key pair, see &lt;a href="#generating-a-request-signature">below&lt;/a> for information on signing your requests to use our API.&lt;/li>
&lt;/ol>
&lt;p>Once you have your access key and secret, you will want to avoid giving others access to them, since they&amp;rsquo;re tied directly to your personal Onshape account. Think of your API key as a username and password pair. Do not place them directly in the code for your application, especially if others might see it. The samples we provide here use a separate configuration file to contain this information, but there are other ways to keep the access key and secret safe, like setting them as environment variables.&lt;/p>
&lt;h3 id="scopes">Scopes&lt;/h3>
&lt;p>There are several scopes available for API keys (equivalent to OAuth scopes):&lt;/p>
&lt;ul>
&lt;li>&lt;code>OAuth2Read&lt;/code> - Read non-personal information (documents, parts, etc.)&lt;/li>
&lt;li>&lt;code>OAuth2ReadPII&lt;/code> - Read personal information (name, email, etc.)&lt;/li>
&lt;li>&lt;code>OAuth2Write&lt;/code> - Create and edit documents, etc.&lt;/li>
&lt;li>&lt;code>OAuth2Delete&lt;/code> - Delete documents, etc.&lt;/li>
&lt;li>&lt;code>OAuth2Purchase&lt;/code> - Authorize purchases from account&lt;/li>
&lt;/ul></description></item><item><title>Docs: Request Signature</title><link>https://onshape-public.github.io/docs/auth/requestsig/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://onshape-public.github.io/docs/auth/requestsig/</guid><description>
&lt;h3 id="custom-authentication">Custom Authentication&lt;/h3>
&lt;p>Basic Authorization via API Keys can be used for quick prototyping and testing. For production use, however, Onshape requires &lt;a href="https://onshape-public.github.io/docs/authen/oauth">OAuth&lt;/a> or this custom authentication process via request signature.&lt;/p>
&lt;p>To ensure that a request is coming from you, we have a process for signing requests that you must follow for API calls to work. Everything is done via HTTP headers that you&amp;rsquo;ll need to set:&lt;/p>
&lt;ol>
&lt;li>&lt;em>Date&lt;/em>: A standard date header giving the time of the request; must be accurate within &lt;strong>5 minutes&lt;/strong> of request. Example: &lt;code>Mon, 11 Apr 2016 20:08:56 GMT&lt;/code>&lt;/li>
&lt;li>&lt;em>On-Nonce&lt;/em>: A string that satisfies the following requirements (see the code for one possible way to generate it):
&lt;ul>
&lt;li>At least 16 characters&lt;/li>
&lt;li>Alphanumeric&lt;/li>
&lt;li>Unique for each request&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;em>Authorization&lt;/em>: This is where the API keys come into play. You&amp;rsquo;ll sign the request by implementing this algorithm:
&lt;ul>
&lt;li>&lt;strong>Input&lt;/strong>: Method, URL, On-Nonce, Date, Content-Type, AccessKey, SecretKey&lt;/li>
&lt;li>&lt;strong>Output&lt;/strong>: String of the form: &lt;code>On &amp;lt;AccessKey&amp;gt;:HmacSHA256:&amp;lt;Signature&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;strong>Steps to generate the signature portion&lt;/strong>:
&lt;ol>
&lt;li>Parse the URL and get the following:
&lt;ol>
&lt;li>The path, e.g. &lt;code>/api/documents&lt;/code> (no query params!)&lt;/li>
&lt;li>The query string, e.g. &lt;code>a=1&amp;amp;b=2&lt;/code>
&lt;ul>
&lt;li>NOTE: If no query paramaters are present, use an empty string&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Create a string by appending the following information in order. Each field should be separated by a newline (&lt;code>\n&lt;/code>) character, and the string must be converted to lowercase:
&lt;ol>
&lt;li>HTTP method&lt;/li>
&lt;li>On-Nonce header value&lt;/li>
&lt;li>Date header value&lt;/li>
&lt;li>Content-Type header value&lt;/li>
&lt;li>URL pathname&lt;/li>
&lt;li>URL query string&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Using SHA-256, generate an &lt;a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code" target="_blank">HMAC digest&lt;/a>, using the API secret key first and then the above string, then encode it in Base64.&lt;/li>
&lt;li>Create the &lt;code>On &amp;lt;AccessKey&amp;gt;:HmacSHA256:&amp;lt;Signature&amp;gt;&lt;/code> string and use that in the Authorization header in your request.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>Below is an example function to generate the authorization header, using Node.js&amp;rsquo;s standard &lt;code>crypto&lt;/code> and &lt;code>url&lt;/code> libraries:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">// ...at top of file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>&lt;span style="color:#00a">var&lt;/span> u = require(&lt;span style="color:#a50">&amp;#39;url&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">var&lt;/span> crypto = require(&lt;span style="color:#a50">&amp;#39;crypto&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* Generates the &amp;#34;Authorization&amp;#34; HTTP header for using the Onshape API
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} method - Request method; GET, POST, etc.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} url - The full request URL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} nonce - 25-character nonce (generated by you)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} authDate - UTC-formatted date string (generated by you)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} contentType - Value of the &amp;#34;Content-Type&amp;#34; header; generally &amp;#34;application/json&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} accessKey - API access key
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @param {string} secretKey - API secret key
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">* @return {string} Value for the &amp;#34;Authorization&amp;#34; header
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">function&lt;/span> createSignature(method, url, nonce, authDate, contentType, accessKey, secretKey) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> urlObj = u.parse(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> urlPath = urlObj.pathname;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> urlQuery = urlObj.query ? urlObj.query : &lt;span style="color:#a50">&amp;#39;&amp;#39;&lt;/span>; &lt;span style="color:#aaa;font-style:italic">// if no query, use empty string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> str = (method + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> + nonce + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> + authDate + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> + contentType + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> urlPath + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span> + urlQuery + &lt;span style="color:#a50">&amp;#39;\n&amp;#39;&lt;/span>).toLowerCase();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> hmac = crypto.createHmac(&lt;span style="color:#a50">&amp;#39;sha256&amp;#39;&lt;/span>, secretKey)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .update(str)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .digest(&lt;span style="color:#a50">&amp;#39;base64&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">var&lt;/span> signature = &lt;span style="color:#a50">&amp;#39;On &amp;#39;&lt;/span> + accessKey + &lt;span style="color:#a50">&amp;#39;:HmacSHA256:&amp;#39;&lt;/span> + hmac;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">return&lt;/span> signature;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="redirects">Redirects&lt;/h3>
&lt;p>Some API endpoints return 307 redirects. You must generate an Authorization header for the redirect as well, but please note that the server portion of the URL might be different, the redirect URL may contain query parameters that must be encoded in the Authorization header, etc.&lt;/p></description></item><item><title>Docs: OAuth</title><link>https://onshape-public.github.io/docs/auth/oauth/</link><pubDate>Mon, 18 May 2020 20:39:14 -0400</pubDate><guid>https://onshape-public.github.io/docs/auth/oauth/</guid><description>
&lt;p>&lt;strong>This page is under construction&lt;/strong>&lt;/p>
&lt;h2 id="what-is-oauth2">What is OAuth2?&lt;/h2>
&lt;p>The OAuth (Open authorization) protocol was developed by the Internet
Engineering Task Force - The Internet Engineering Task Force is an open
standards organization, which develops and promotes voluntary Internet
standards, in particular the technical standards that comprise the
Internet protocol suite – it enables secure delegated access to an
applications resources.&lt;/p>
&lt;p>The OAuth2 protocol enables an application to access a resource that is
under the control of someone else. In order to access that resource a
Token is required. The Token represent the delegated rights of access
(defines what rights this application has such as read/write/update,
scope, rights to different resources and more). In this way the
application can be accessed by a third party system without that system
impersonating the user who controls the resource.&lt;/p>
&lt;p>A good analogy is the hotel check-in process.&lt;/p>
&lt;p>When you arrive at the front desk of a hotel you are generally asked to
provide an ID and a form of payment. In response you are provided with a
key card that opens a specific door. When you reach that door, you swipe
your key card and you are granted access. The door itself doesn’t know
who you are or anything about you – it just knows that the key card was
encoded correctly, and it allows you access. At some point in time the
key card expires and the door no longer lets you into the room. This is
the same for Access Tokens in the OAuth2 flow.&lt;/p>
&lt;p>With the OAuth2 protocol, you register your application with the
3&lt;sup>rd&lt;/sup> party, you are given a set of keys. These keys get
exchanged for an Access Token that grants you access to resources in the
3&lt;sup>rd&lt;/sup> party application. Every now and then that token expires
and in order to access the resources, you are required to get a new
token. For this, you are provided with a refresh token. Sending the
refresh token to the authentication server will provide you with your
updated access token and a new refresh token. In our analogy the
Authorization server is the same as the clerk at the check-in desk, he’s
validating that we’re registered and that we can in fact access the
resources in the hotel. Once validated he provides us with a key card =
authorization token. With this card we can now access our room, the gym
and possibly some other hotel resources. Likewise, the authorization
token enables us to access the API resources.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage20.png"
style="width:5.2782in;height:3.375in"
alt="Getting Started with OAuth2 - Keap Developer Portal" />&lt;/p>
&lt;p>The first step to the OAuth flow is for the Onshape user to request
Onshape to authorize access for the 3&lt;sup>rd&lt;/sup> party application to
access Onshape.&lt;/p>
&lt;p>Once the user has authorized the application, they will be redirected to
a predefined URL together with a code that will be used to request an
access token from Onshape. Therefore, the redirect URL should contain a
script that can capture the authorization code.&lt;/p>
&lt;p>The access token is the token you will use to authenticate requests to
the Onshape API. Note that the token expires after predefined set amount
of time. In order to get a new valid access token after one has expired,
you must use the refresh token to request a new access token.&lt;/p>
&lt;p>Refreshing the Access Token will also provide you with an updated
refresh token that will be used in the next refresh access token
request. Make sure to store both the access token and the refresh token
and update them with each refresh of the token.&lt;/p>
&lt;p>The authorization token must accompany any call to the API, this is done
by adding the token to an Authorization field in the header of each
request:&lt;/p>
&lt;p>&lt;code>‘Authorization’ : ‘Bearer \[authorization code here\]’&lt;/code>&lt;/p>
&lt;p>If correctly authenticated, the response from the REST API call will be a
stream of JSON data with an HTTP response code of 200.&lt;/p>
&lt;p>In the event that the authorization code is incorrect – for instance, if
it expired, you will receive an &lt;strong>HTTP 401&lt;/strong> response. This response
means that the client request has not been completed since it lacks
valid authentication credentials for the requested resource. In this
event your code for each call to the REST API should include a catch
clause for a 401 exception. Once caught, you can refresh the token and
make the request again.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />&lt;/p>
&lt;p>A very good resource for
learning more about OAuth2 can be found at
&lt;a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2&lt;/a>&lt;/p>
&lt;h2 id="oauth-20-and-onshape">OAuth 2.0 and Onshape&lt;/h2>
&lt;p>When integrating with Onshape, OAuth tokens authorize third-party applications (such as a desktop application or a web service) for limited access to users&amp;rsquo; Onshape documents. Using OAuth terminology, Onshape acts as both the authorization and resource server, while the desktop or web-based application is the client. Resource owners have the option of granting or denying access to applications.&lt;/p>
&lt;p>RFC 6749 (&lt;a href="http://tools.ietf.org/html/rfc6749" target="_blank">&lt;a href="http://tools.ietf.org/html/rfc6749">http://tools.ietf.org/html/rfc6749&lt;/a>&lt;/a>) is the reference for the OAuth framework as a whole. Most of this document describes how to implement the OAuth exchanges described by the reference within the context of Onshape and client applications. RFC 6750 (&lt;a href="http://tools.ietf.org/html/rfc6750" target="_blank">&lt;a href="http://tools.ietf.org/html/rfc6750">http://tools.ietf.org/html/rfc6750&lt;/a>&lt;/a>) describes the exchange of OAuth access tokens between clients and OAuth servers.&lt;/p>
&lt;p>Once obtained an OAuth token will work for third-party APIs under &lt;code>/api&lt;/code>. It&amp;rsquo;s not appropriate to attempt to use an OAuth token to fetch the URLs typically displayed in a web browsers location bar.&lt;/p>
&lt;h2 id="implement-oauth2">Implement OAuth2&lt;/h2>
&lt;p>In this section, we take a look at some sample code of how the OAuth2
authorization flow is enabled. We’re not showing the complete code here,
just the relevant parts of the code that relate to authentication
against Onshape and using the REST API with the acquired access token.
There are plenty of online resources that show this flow in more detail,
but here we are focused on the implementation of OAuth2 in regards
to Onshape.&lt;/p>
&lt;p>The code samples are provided in node.JS, however you are free to use
any programming language of your choice in developing your integration.
There are good resources on the Onshape public GitHub in both node.JS,
Python, Java and C#:
&lt;a href="https://github.com/onshape-public">https://github.com/onshape-public&lt;/a>.&lt;/p>
&lt;p>So far, we have registered our application with Onshape and received an
OAuth Client ID and an OAuth Client Secret string. We will be using
these strings in this section in order to receive a one-time user
authorization code.&lt;/p>
&lt;h3 id="1-register-the-app">1: Register the app&lt;/h3>
&lt;p>OAuth relies on an orchestrated set of interactions between the web browser, Onshape&amp;rsquo;s web services and third-party client applications (which may be desktop or web server-based). The orchestration takes the form of a sequence of requests and subsequent browser redirections between pre-configured URL endpoints. In order to take part in the OAuth process an application must first be registered with Onshape.&lt;/p>
&lt;p>You can follow along with the steps below with this video:
&lt;a href="https://onshape.wistia.com/medias/7x7q7d5fr9">&lt;img src="https://onshape-public.github.io/images/OAuthVideoCard.png" style="width:5in" alt="OAuth app creation video"/>&lt;/a>&lt;/p>
&lt;ol>
&lt;li>To get started, you must request a login for: &lt;a href="https://dev-portal.onshape.com/">https://dev-portal.onshape.com/&lt;/a>. Please email
&lt;a href="mailto:api-support@onshape.com">api-support@onshape.com&lt;/a> to obtain your login.&lt;/li>
&lt;li>Create a new OAuth application in the Developer Portal.&lt;/li>
&lt;li>Click &lt;strong>OAuth applications&lt;/strong> in the left sidebar&lt;/li>
&lt;li>Click the &lt;strong>Create new OAuth application&lt;/strong> button in the top right.&lt;/li>
&lt;li>Fill out the screen fields as follows:
&lt;ol>
&lt;li>&lt;strong>Name&lt;/strong> – this is the application name that you wish to display to
the users. It should include the name of your company to
differentiate it from other possibly similar application. I.e.
“JambaCorp PLM” instead of just “PLM”.&lt;/li>
&lt;li>&lt;strong>Primary format&lt;/strong> - this string uniquely identifies your
application and is a marker for the data it might store on Onshape
servers. It should take the form of a Java style reverse domain
name: com.jambacorp.plm. This value cannot be changed after the
application is registered.&lt;/li>
&lt;li>&lt;strong>Summary&lt;/strong> – this is a description of your application. This is
displayed to the user when they’re asked to grant the application
permission to access their data.&lt;/li>
&lt;li>&lt;strong>Redirect URLs&lt;/strong> - Your application must specify at least one URL
used in the OAuth protocol exchanges. This URL must also use SSL (a
URL that begins with https), with two exceptions applicable for
installed desktop applications. Possible reasons for specifying more
than one redirect URI is if you deploy “test” and “production”
versions of your application, and want to use a specific version of
your application for different sets of users.&lt;/li>
&lt;li>&lt;strong>Admin Team&lt;/strong> – Optional. If defined, members of the team can make changes to the definition of this OAuth application. See the &lt;a href="https://cad.onshape.com/help/Content/teams-enterprise.htm">Help Docs: Teams&lt;/a> page for more information on creating teams in Onshape.&lt;/li>
&lt;li>&lt;strong>OAuth URL&lt;/strong> – This URL is the “Authentication Page” for your
application. This is the first URL called from the Onshape
Applications page (described in detail in the next section). The
page hosted at this URL should handle the OAuth authentication. Once
your application’s server has been authenticated on behalf of the
user, that user should be redirected to your applications content.&lt;/li>
&lt;li>&lt;strong>Permissions&lt;/strong> – this is also called application scope and it
defines what access rights you want your application to have with
regards to the user’s data. The options are as follows:
&lt;ul>
&lt;li>&lt;strong>Application can read your profile information&lt;/strong>: Enable your application to access the Onshape user profile.&lt;/li>
&lt;li>&lt;strong>Application can read your documents&lt;/strong>: Onshape documents created by this user can be accessed with read privileges only.&lt;/li>
&lt;li>&lt;strong>Application can write to your documents&lt;/strong>: The user-owned Onshape documents can be modified by this application.&lt;/li>
&lt;li>&lt;strong>Application can delete documents and workspaces&lt;/strong>: Your application will be able to delete a workspace within a document or the complete Onshape document.&lt;/li>
&lt;li>&lt;strong>Application can request Purchases on Your behalf&lt;/strong>: The application will have access to make purchases if required.&lt;/li>
&lt;li>&lt;strong>Application can share and unshare documents on your behalf&lt;/strong>: Onshape’s document sharing capabilities are very powerful; they enable other parties to access your shared documents with
predefined rights. If this option is checked, the application can automatically share a document with other people.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Click the &lt;strong>Create Application&lt;/strong> button.&lt;/li>
&lt;li>Save the &lt;code>OAuth Client ID&lt;/code> and &lt;code>OAuth Client Secret string&lt;/code> that are displayed. These keys will be used in your code for requesting a one-time user authorization code from Onshape. They identify the registered application to Onshape. While the Client ID is considered public (it is how your specific application is uniquely identified in OAuth protocol exchanges), the Client Secret must be stored securely. For example, it should &lt;em>NOT&lt;/em> be checked in to source code control systems. Protect the Client Secret as you would any password data. You will NOT be shown this secret again!&lt;/li>
&lt;/ol>
&lt;p>Your application is now registered with Onshape and you have options to
modify the application definition through this portal.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage22.png"
style="width:4.95449in;height:2.74509in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;h3 id="2-get-the-user-authorization-code">2 Get the user authorization code&lt;/h3>
&lt;p>We’ll start by loading the basic libraries required to run this sample.
Since this is node.JS I’m using npm to directly load the libraries into
my development environment.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />The samples here just relate
to the authentication portions of the code and assume that you have
knowledge on setting up and running a Node.js server. All the settings
in this sample are stored in an .env file and referenced through config
class. Where required I have made comments which expected value each
setting is referencing&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Passport is Express
compatible authentication middleware for Node.js. Its sole purpose is to
authenticate requests which it does through plugins known as strategies.
In this sample we are using an Onshape developed plugin
“passport-onshape”, however this is not mandatory, and you can define
your own strategy to use with passport. The passport API is very
straightforward; you provide Passport a request to authenticate, and
passport will provide hooks for controlling what occurs when
authentication succeeds or fails. For more information on Passport
please reference &lt;a href="https://www.npmjs.com/package/passport">https://www.npmjs.com/package/passport&lt;/a>&lt;/p>
&lt;p>To install Passport&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>$ npm install passport
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To install passport-onshape plugin for Passport&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>$ npm install passport-onshape
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Define your app.js (Server file).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> express = require(&lt;span style="color:#a50">&amp;#39;express&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> session = require(&lt;span style="color:#a50">&amp;#39;express-session&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> passport = require(&lt;span style="color:#a50">&amp;#39;passport&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> OnshapeStrategy = require(&lt;span style="color:#a50">&amp;#39;passport-onshape&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tell Express to use Passport and initialize passport&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">var&lt;/span> app = express();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(session({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret: session_secret,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resave: &lt;span style="color:#00a">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> saveUninitialized: &lt;span style="color:#00a">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(passport.initialize());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(passport.session());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Store Onshape user information so it can be retrieved from req.user in
each call.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>passport.serializeUser((user, done) =&amp;gt; done(&lt;span style="color:#00a">null&lt;/span>, user));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>passport.deserializeUser((obj, done) =&amp;gt; done(&lt;span style="color:#00a">null&lt;/span>, obj));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notes on serializeUser and deserializeUser:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Passport uses the
serializeUser function to persist user data (after successful
authentication) into the session. The function deserializeUser is used
to retrieve user data from session.&lt;/p>
&lt;p>Passport needs the following setup to save user data after
authentication in the session:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>app.use(session({ secret: session_secret }));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(passport.initialize());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(passport.session());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The following diagram explains what happens with the serialize and
deserialize functions.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />To learn more about Passport
please reference &lt;a href="https://www.npmjs.com/package/passport">https://www.npmjs.com/package/passport&lt;/a>&lt;/p>
&lt;p>Initialize Passport with the Onshape Strategy&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>passport.use(&lt;span style="color:#00a">new&lt;/span> OnshapeStrategy({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clientID: oauth_clientid, &lt;span style="color:#aaa;font-style:italic">//the client ID string that you got when registering the app with Onshape
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> clientSecret: oauth_clent_secret, &lt;span style="color:#aaa;font-style:italic">//The secret string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> callbackURL: oauth_callback, &lt;span style="color:#aaa;font-style:italic">//The Oauth Callback URL ex: /oauthRedirect
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> authorizationURL: oauthurl, &lt;span style="color:#aaa;font-style:italic">//https://oauth.onshape.com/oauth/authorize
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> tokenURL: oauthtokenurl, &lt;span style="color:#aaa;font-style:italic">//https://oauth.onshape.com/oauth/token
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> userProfileURL: userprofileurl &lt;span style="color:#aaa;font-style:italic">//https://cad.onshape.com/api/users/sessioninfo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(accessToken, refreshToken, profile, done) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> profile.accessToken = accessToken;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> profile.refreshToken = refreshToken;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">//Here you can store the user profile, accessToken, RrefreshToken in your database
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span> userController.updateUser(accessToken, refreshToken, user).then((data)=&amp;gt;{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">return&lt;/span> done(&lt;span style="color:#00a">null&lt;/span>, data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The OnshapeStrategy takes six values, all which should be stored in your
&lt;code>.env&lt;/code> (or configuration) file. There are several values that don’t change
and should use the following definitions:&lt;/p>
&lt;ol>
&lt;li>&lt;code>authorizationURL : &amp;lt;https://oauth.onshape.com/oauth/authorize&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>tokenURL : &amp;lt;https://oauth.onshape.com/oauth/token&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>userProfileURL : &amp;lt;https://cad.onshape.com/api/users/sessioninfo&amp;gt;&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>The callback function will provide us with the &lt;code>accessToken&lt;/code>, the
&lt;code>refreshToken&lt;/code> and the user’s Onshape profile once authentication has been
successfully passed. We can now use this to update our database with
user specific information.&lt;/p>
&lt;p>Note that if you store the &lt;code>accessToken&lt;/code> and &lt;code>refreshToken&lt;/code> in the database along with the user record,
this will have to be updated each time that the access codes are
refreshed.&lt;/p>
&lt;p>Next we define our endpoint where the authorization flow starts in this
case &lt;code>/oauthSignin&lt;/code>. This is the endpoint that we previously defined in
the Onshape application setup. This will redirect to an Onshape page in
order for the user to confirm (or deny) the applications access to the
Onshape resources.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>app.use(&lt;span style="color:#a50">&amp;#39;/oauthSignin&amp;#39;&lt;/span>, (req, res) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">return&lt;/span> passport.authenticate(&lt;span style="color:#a50">&amp;#39;onshape&amp;#39;&lt;/span>, { state: uuid.v4() })(req, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}, (req, res) =&amp;gt; { &lt;span style="color:#aaa;font-style:italic">/* redirected to Onshape for authentication */&lt;/span> });
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>state&lt;/code> fields can be used
to store relevant information (such as &lt;code>documentId&lt;/code>, &lt;code>elementId&lt;/code>,
&lt;code>workspaceId&lt;/code>, etc.) in the event that this information is sent from
Onshape. In this sample we have not defined any fields.&lt;/p>
&lt;p>The following page is displayed:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage23.png"
style="width:4.74911in;height:3.28125in"
alt="Graphical user interface, application, Teams Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977885" class="anchor">&lt;/span>Figure 14 - Onshape
Authorize Application Interface&lt;/p>
&lt;p>This page pulls information, such as the name, the description, the
permissions from the original application setup in Onshape. Once the
user clicks on the &lt;strong>Authorize application&lt;/strong> button, the flow will
redirect to the redirectURL defined in the application setup.&lt;/p>
&lt;h3 id="3-exchange-the-code-for-an-access-token">3 Exchange the code for an access token&lt;/h3>
&lt;p>Fortunately, if you are using Passport, there isn’t much to do once the user clicks the &lt;strong>Authorize Application&lt;/strong> button. The return URL will contain the one-time authorization token and the
passport will extract that and exchange it for an access Token and a
refresh token. These will be available in the Passport callback function
shown previously.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">//OAuth2 redirect code will be replaced for a token
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.use(&lt;span style="color:#a50">&amp;#39;/oauthRedirect&amp;#39;&lt;/span>, passport.authenticate(&lt;span style="color:#a50">&amp;#39;onshape&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>failureRedirect: &lt;span style="color:#a50">&amp;#39;/grantDenied&amp;#39;&lt;/span> }), (req, res, next) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">// additional optional redirect parameters to be added to the redirect
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>URL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res.redirect(&lt;span style="color:#a50">`/?authsuccess=true`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>next();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the above code, there are a few interesting points.&lt;/p>
&lt;p>First, if the user clicked the &lt;strong>Deny&lt;/strong> button, the user is taken
to a page that notifies them that access to the application was denied. We
can see that in the &lt;code>failureRedirect&lt;/code> argument. The route for calling
the &lt;code>grantDenied.html&lt;/code> page is defined below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>app.get(&lt;span style="color:#a50">&amp;#39;/grantDenied&amp;#39;&lt;/span>, (req, res, next) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res.sendFile(path.join(__dirname, &lt;span style="color:#a50">&amp;#39;public&amp;#39;&lt;/span>, &lt;span style="color:#a50">&amp;#39;html&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a50">&amp;#39;grantDenied.html&amp;#39;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Another interesting point is the following line:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>res.redirect(&lt;span style="color:#a50">`/?authsuccess=true`&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, we can add additional parameters to the URL that gets called once
the OAuth process completes successfully. In this case, we add a
simple argument that lets the &lt;code>index&lt;/code> page know that authorization
completed successfully. The &lt;code>index&lt;/code> page then produces a notification that
the application has been successfully authenticated by Onshape.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage24.png" style="width:6.5in;height:1.88611in"
alt="Graphical user interface, text, application, website Description automatically generated" />&lt;/p>
&lt;h3 id="4-use-the-access-token">4 Use the access token&lt;/h3>
&lt;p>Our application is now registered and successfully authenticated by
Onshape. This means that the application can access Onshape’s resources
as long as a valid access token is provided along with our API calls.&lt;/p>
&lt;p>The &lt;code>access_token&lt;/code> must be supplied on all subsequent Onshape API
requests as a header value: &lt;code>Authorization: Bearer \&amp;lt;access_token\&amp;gt;&lt;/code>. The
access token uniquely identifies the combination of your application,
the Onshape user, and the set of permissions granted for the access
token.&lt;/p>
&lt;p>The access token has a limited lifetime of 60 minutes, after which it
will no longer work, and attempts to use it will result in an error
response for an Onshape API request. The application must use the
refresh token returned by the original authorization code exchange to
generate new access tokens.&lt;/p>
&lt;p>The following code is a complete example of getting metadata for a
specific Part. The &lt;code>documentId&lt;/code>, &lt;code>workspaceId&lt;/code>, &lt;code>elementID&lt;/code> and &lt;code>partId&lt;/code> have
been sent over as arguments. The user data, including the access token
and the refresh token, is included in the request object.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage25.emf" alt="">&lt;/p>
&lt;p>For making the web call, we use a library called &lt;code>axios&lt;/code>. There are
many such libraries available on &lt;code>npm&lt;/code>.&lt;/p>
&lt;p>To initiate the &lt;code>axios&lt;/code> library after
installing it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a">const&lt;/span> axios = require(&lt;span style="color:#a50">&amp;#39;axios&amp;#39;&lt;/span>).&lt;span style="color:#00a">default&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>More details regarding the axios library can be found here:
&lt;a href="https://www.npmjs.com/package/axios">https://www.npmjs.com/package/axios&lt;/a>.&lt;/p>
&lt;p>In the code above, note the catch clause:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>}).&lt;span style="color:#00a">catch&lt;/span>(&lt;span style="color:#00a">function&lt;/span> (data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">if&lt;/span> (data.response.status === &lt;span style="color:#099">401&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> authentication.refreshOAuthToken(req, res).then(&lt;span style="color:#00a">function&lt;/span> () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getMetadata(docid, wsid, eleid, pid, req, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If the call to the Onshape API fails for any reason, it is caught by this
catch clause. The first reason for failure would probably be because the
&lt;code>accessToken&lt;/code> has expired. This would return an &lt;code>HTTP 401 error – not authorized&lt;/code>.&lt;/p>
&lt;p>In this case, we send a request to refresh the access
token. Once that request comes back with a new token, we call our
&lt;code>getMetadata&lt;/code> function again.&lt;/p>
&lt;p>The refresh token functionality is explained in detail in the next
section.&lt;/p>
&lt;p>In the code above, all the metadata properties are returned in JSON
format in the &lt;code>response.data.properties&lt;/code> object.&lt;/p>
&lt;p>&lt;strong>NOTE:&lt;/strong> that in the &lt;code>authentication.refreshOAuthToken&lt;/code> call, &lt;code>authentication&lt;/code> is a library of
methods related to authenticating the user and the application through
OAuth2. For simplicity, we placed all calls in the &lt;code>app.js&lt;/code> file, but it is a better practice to organize
all the OAuth2 calls in the same library.&lt;/p>
&lt;h3 id="5-refresh-the-token">5 Refresh the token&lt;/h3>
&lt;p>We have already seen a call to refresh the access token in the previous
section. As mentioned previously, we&amp;rsquo;ve put all OAuth2 refresh code in the
authentication library.&lt;/p>
&lt;p>When the access token expires, it must be refreshed by making another
&lt;code>POST&lt;/code> request to &lt;code>https://oauth.onshape.com/oauth/token&lt;/code> with the following
URL encoded form body (again, with
&lt;code>Content-Type application/x-www-form-urlencoded&lt;/code>):&lt;/p>
&lt;p>&lt;code>grant_type=refresh_token&amp;amp;refresh_token=\&amp;lt;refresh_token\&amp;gt;&amp;amp;client_id=\&amp;lt;client_id\&amp;gt;&amp;amp;client_secret=\&amp;lt;client_secret\&amp;gt;&lt;/code>&lt;/p>
&lt;p>As with the authorization code data, the parameters in the form body
must be URL encoded. The response to this &lt;code>POST&lt;/code> request will be a JSON
encoded structure as before with a new &lt;code>access_token&lt;/code> value that can be
used for the next 60 minutes.&lt;/p>
&lt;p>Refresh tokens are valid for
the lifetime of the user’s grant. If a user who previously granted
access to your application decides to revoke the grant, the refresh
token is invalidated. If the user decides to re-grant application
access, a new refresh token is generated and returned along with the
access token.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that in this sample it
is using the npm package “request” to make the web call. This package
has since been depreciated and you should use another supported package,
such as axios.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage26.emf" alt="">&lt;/p>
&lt;p>We use the variable pendingTokenRefreshes to hold the value of the
session.id. If pendingTokenRefreshes is populated with the session.id,
that would mean that there is a token refresh already pending. This
would occur if there were multiple calls to the Onshape API while the
refresh was still pending.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage27.emf" alt="">&lt;/p>
&lt;p>The final part of the relevant code is the onOAthTokenReceived. This is
called following a successful call to refresh the token. The access
token and the refresh token are updated in the req.user object and if
you wish you can update the database with the refreshed information.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage28.emf" alt="">&lt;/p>
&lt;h3 id="6-user-grants-authorization">6 User grants authorization&lt;/h3>
&lt;p>As mentioned previously, it is the Onshape user who actually grants
authorization to the third-party application to access the Onshape data.
This must be done by each user who needs to work with the third-part
application.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />In order to grant access,
after logging into Onshape, the user should click on the top right menu
that drops down from their name.&lt;/p>
&lt;p>Note that this menu will look different depending upon the users
specific rights and enterprises that he/she has access to.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage29.png"
style="width:1.89869in;height:2.26471in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>Click in the “My Account” option. This will bring up the user’s profile.
The click on the “Applications” option on the left side menu.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage30.png" style="width:6.5in;height:3.20764in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>This is where the user grants access to an application. Find the
third-party application that you wish to authorize and click on the
“Grant” button in the “Onshape access” column.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that where you see a
“Grant” button in the “external access” column, this means that the
application requires Onshape to access its resources. We will examine a
business case in the next section where this is a requirement.&lt;/p>
&lt;p>Once you click on the “Grant” button, you should see a page similar to
the following “Authorize Application” screen shown below.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage23.png"
style="width:5.13542in;height:3.54816in"
alt="Graphical user interface, application, Teams Description automatically generated" />&lt;/p>
&lt;p>Click to authorize the application and you will now be redirected to
that application and access to the Onshape resources and your user
profile in Onshape would have been granted successfully.&lt;/p>
&lt;h2 id="notes">Notes&lt;/h2>
&lt;h3 id="installed-desktop-applications">Installed desktop applications&lt;/h3>
&lt;p>OAuth is designed for interactions between two servers utilizing a browser. However it can also be used by an installed desktop (or mobile) application. The application must perform a similar role to that of a third party server - it must exchange the code for an access token structure.&lt;/p>
&lt;p>In order to enable this to be as automatic as possible Onshape allows two special forms of redirect URI to be registered: &lt;code>http://localhost:&amp;lt;port&amp;gt;&lt;/code> and &lt;code>urn:ietf:wg:oauth:2.0:oob&lt;/code>&lt;/p>
&lt;p>The first causes the browser to attempt to load a page from the host upon which it is running. The code parameter etc will be supplied exactly the same as outlined above. If the application can listen on the registered port and behave as a simple web server for the redirect URI it can retrieve the code in the same way as a deployed web server would.&lt;/p>
&lt;p>The second will cause the browser to display a simple page containing the code after a request has been granted instead of going to a new URI. The page contains simple instructions to copy and paste the code into an application field. The browser will also update the title of the window to contain the code. An application could also look for browsers with window titles containing the string &lt;code>Success code=&amp;lt;code&amp;gt;&lt;/code> and automatically grab the code from the browser window title. If an error occurs (the grant is denied for example) then the browser window title will contain &lt;code>Error description=&amp;lt;error string&amp;gt;&lt;/code>&lt;/p>
&lt;h3 id="debugging">Debugging&lt;/h3>
&lt;p>Debugging OAuth can be a little tricky. Here are some things to bear in mind:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Make sure you are correctly URL encoding the values supplied to the oauth/authorize and oauth/token endpoints.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Use a &lt;code>GET /oauth/authorize&lt;/code> but a &lt;code>POST /oauth/token&lt;/code> and make sure that the GET uses query parameters but that the POST uses a URL encoded form body.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If you supply a &lt;code>redirect_uri&lt;/code> to &lt;code>/oauth/authorize&lt;/code> you must also supply it as an additional parameter in the POST to /oauth/token&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Use a tool such as Burp (&lt;a href="https://portswigger.net/burp" target="_blank">&lt;a href="https://portswigger.net/burp">https://portswigger.net/burp&lt;/a>&lt;/a>) or Charles (&lt;a href="http://charlesproxy.com" target="_blank">&lt;a href="http://charlesproxy.com">http://charlesproxy.com&lt;/a>&lt;/a>) to deliberately &amp;lsquo;man-in-the-middle&amp;rsquo; the connection requests between your server and Onshape, and verify that you are performing the correct REST operations (GET vs. POST) and correctly URL encoding the parameter values.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="oauth2-summary">OAuth2 Summary&lt;/h2>
&lt;p>Implementing OAuth2 can be complex since it’s a multi-step process that
requires specific data to be delivered at specific times in a specific
format. Using a library such as Passport does make our lives a lot
easier when implementing such a solution.&lt;/p>
&lt;p>We’ve covered a lot of ground in this section. First, defining a
third-part application in Onshape, understanding what OAuth2 is and how
it works through concrete examples of how to implement it and
communicate with Onshape.&lt;/p>
&lt;p>In the end, simplifying the explanation, OAuth2 is a three-step process
that secures your applications and guarantees that an application isn’t
impersonating a user when it access the resources, but is a validated
“known” entity that the user approves to access the data.&lt;/p>
&lt;p>The code shown here is sample code intended to provide you with the
logic of how this process works. If you’ve implemented OAuth previously
this should be very self explanatory, and if not, feel free to use these
code samples and adjust them to your own needs.&lt;/p>
&lt;p>It is important to mention that if you wish Onshape to access data from
your application, the same sort of mechanism must be implemented in your
code. Onshape supports through its app extensions the ability to connect
through OAuth2 to a third-party app and retrieve data from that
application. This implementation I shown in the next section where we
get into specific business cases for integration.&lt;/p></description></item></channel></rss>