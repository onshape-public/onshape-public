<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Onshape Developer Documentation – Sample Tutorials</title><link>https://onshape-public.github.io/docs/tutorials/</link><description>Recent content in Sample Tutorials on Onshape Developer Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 07 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://onshape-public.github.io/docs/tutorials/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Sync Data and Metadata</title><link>https://onshape-public.github.io/docs/tutorials/sync/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://onshape-public.github.io/docs/tutorials/sync/</guid><description>
&lt;p>The first business case is probably the most common, “How do I sync data
that I create in Onshape with my ERP or PLM system?”. There could be
many reasons why you would want to sync data between two different
systems. Primarily Onshape is a system that creates new data. This data
is created by designers as they perform their daily tasks. While the
designer works primarily in Onshape, the actual data that they create
does not exist in a vacuum, it is used by other departments, other
processes within the organization. These departments and processes
probably do not have access to Onshape or the required knowledge of how
to use Onshape. In addition, quite often, the data generated by Onshape
will be augmented with additional data as the product lifecycle process
progresses.&lt;/p>
&lt;p>Therefore, Onshape could be considered the genesis of the data that will
be used to develop a product, yet it is not the only data that will be
required.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>In this business case we examine how a designer could work in Onshape
and how the data generated by Onshape can be used to make decisions in
other systems. Based upon the decisions made, data is pushed back to
Onshape as values calculated in another system. Let’s look at the
process in much more detail.&lt;/p>
&lt;h3 id="step-1-define-properties-in-onshape">Step 1: Define Properties in Onshape&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage31.png"
style="width:5.41667in;height:1.84722in"
alt="Diagram Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>In the first step, the designer starts a new part in Onshape –
remember that in Onshape a Part can be created along with other
parts in a Part Studio, so we can assume that there could be
multiple parts created in the single document. Obviously, we want
the designer to have the freedom to use all Onshape functionality
without constraints placed by the demands of the integration.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>At some point in the design process, the designer will be required
to enter property values for the part – these could include values
such as the Part Name, the description, material and so on.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The designer clicks the “Save” or “Apply” button for the properties
and closes the properties window.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>A web hook that listens to any changes in the properties has been
defined. As the user saves the properties, the web hook is
triggered, and it will send a notification through the defined web
hook to the third-party system.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note: There are Part
properties, workspace properties and document properties – all these
properties live at different levels of the document. While the trigger
could pick up changes to any to these properties, we are currently
focused on just Part properties – the event will be triggered on any
saving of properties, however our third-party code can ignore anything
that’s not a Part (or an Assembly). In this next step we assume that a
new object is being created in the third-party application.&lt;/p>
&lt;h3 id="step-2-create-corresponding-object">Step 2: Create Corresponding Object&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage32.png"
style="width:5.16667in;height:2.13889in"
alt="Diagram Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Once the designer made changes to the properties in Onshape and
saved those changes, a message is sent to our third-party
application. This message is in JSON format and contains minimal
information such as the Workspace ID, the Document ID, the Element
ID, the Part ID (if it’s a Part) and information regarding the event
that was triggered. The third-party application receives this
information to an endpoint that was defined during the setup of the
web hook.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The code in our application can now use the ID’s sent over to check
if an object with corresponding IDs exists in our system. Here we
are assuming that no such object exists. This does mean that we must
store Onshape IDs into our objects in the third-party system.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We then create a new object and populate the ID information and save
it to the database. Note that at this point in time, we only have
minimal information that provides no more than the identity of the
Onshape Part.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Next, in order to get the complete metadata, we must make a REST API
call to Onshape in order to get the metadata for the part. Since we
were provided the ID information in the web hook, we have enough
information to go back to Onshape and request the metadata for a
specific, document, element, workspace and part.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that you can either
store the Onshape IDs in separate fields in your database or as one long
unique string which can be used to easily identify the part in your
application.&lt;/p>
&lt;h3 id="step-3-get-onshape-metadata">Step 3: Get Onshape Metadata&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage33.png"
style="width:5.75in;height:2.04167in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The response from the call to the Onshape API is sent back as JSON.
The data will contain a lot of different objects that represent the
property values, their types, the IDs, name of the property, value
of the property, etc.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Once received this data must be parsed by your third-party
application code and the corresponding object updated as required.
For bi-directional update, it is important to store the Onshape
property IDs of any data that will need to be synced back to Onshape
from the third-party application.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This is an optional stage. Once you have all the metadata values
imported, you could now calculate any values that are based off the
metadata. The most common use case scenario is the generation of
intelligent part numbers. Based off configuration, part type, etc.,
you could generate a part number that has specific meaning within
the context of the company.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If you calculated specific values, you can now store them in your
database.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="step-4-modify-properties-in-onshape">Step 4: Modify Properties in Onshape&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage34.png"
style="width:5.04167in;height:3.97222in"
alt="Diagram Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>As in Step 1 the designer updates the properties in Onshape – this
is obviously something that can happen multiple times&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The web hook is triggered when the designer saves the property
changes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Our third-party application is listening for property changes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The third-party application’s code will check if the corresponding
object exists based off the IDs sent from Onshape.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>In this scenario the corresponding object has already been saved in
our system&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We make a REST API call to Onshape to get the metadata based off the
IDs sent from Onshape.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Onshape returns the JSON that represents the updated properties&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We ingest the updated metadata and update our existing object in the
third-party system.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="step-5-request-part-number">Step 5: Request Part Number&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage35.png"
style="width:5.76389in;height:2.13889in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>As we will see later, Onshape has the built in capability to pull
custom part numbers from a third-party system. From either the
properties window or the release candidate window, click the button
to request a part number&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Onshape sends basic ID information to a predefined endpoint in our
third-party app.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The ID information sent by Onshape is enough data to find the
corresponding object in our database. We then extract from that
object the pre-calculated intelligent part number – or we can
calculate it at this point.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The part number is returned to Onshape and populated in the Part
Number field&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that in order to pull a
part number from a third-party application we will need to implement
OAuth2 in our application and grant Onshape access to the resources of
our application. Onshape has a very good mechanism for achieving this
and we will be explaining this in detail in this section.&lt;/p>
&lt;p>Note that by default Onshape uses its own internal Part number
generator, in order to use a custom third-party generator, we will need
to define an app extension and then define in the Enterprise release
settings to use our custom part number generator.&lt;/p>
&lt;h3 id="step-6-push-updates-from-third-party-application">Step 6: Push Updates from Third-Party Application&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage36.png"
style="width:5.75in;height:2.45833in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>In this scenario we are updating an Object in our third-party
application and expecting that some of the property values will be
updated in Onshape. We can either send over all the properties
populated for this object, or a subset of properties and values&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The REST API to update properties in Onshape requires that we
reference the IDs of the properties that we are updating. For this
reason we have stored the Onshape property IDs with our metadata
object in our database.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We construct the correct JSON that contains all the properties to
update and the new values. We can then call the Onshape REST API to
update the properties in Onshape with the new data.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Once successfully completed, the Onshape REST API call will return
HTTP 200 and we can notify the user if needed.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that updates to Onshape
will happen behind the scenes in real-time, therefore someone working on
the document in Onshape will be able to see the updates as soon as they
have been made. There is no notification in Onshape that notifies the
user that properties have been updated, however you can open the
properties window and view the updated data.&lt;/p>
&lt;h2 id="implementation">Implementation&lt;/h2>
&lt;p>We’ll start by defining an &lt;a href="https://onshape-public.github.io/docs/app-dev/extensions">App Extension&lt;/a> in Onshape so that we can
receive custom part numbers.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />&lt;/p>
&lt;h3 id="debug">Debug&lt;/h3>
&lt;p>All Browsers now have developer tools exposed in their interface. These
tools provide us ways to debug client code, view console messages and
most importantly for our use case, view Network requests and their
response.&lt;/p>
&lt;p>In this example I am using Chrome’s developer tools. Most other Browsers
have more or less copied Chrome’s layout for the developer tools so it
should be easy to find the network section.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage39.png"
style="width:5.36972in;height:4.16096in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977895" class="anchor">&lt;/span>Figure 24 Accessing
Chrome&amp;rsquo;s Developer Tools&lt;/p>
&lt;p>Let’s take the simple use case of trying to understand which endpoint
Onshape uses for saving Metadata.&lt;/p>
&lt;p>Open a document in Onshape and define some properties – don’t save yet.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage40.png"
style="width:3.42406in;height:2.25966in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>Prior to saving open the developer tools and click on the “Network” tab.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage41.png" style="width:6.5in;height:2.37014in"
alt="Table Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977896" class="anchor">&lt;/span>Figure 25 Developer Tools
Network Tab&lt;/p>
&lt;p>Next save the updated properties by clicking either the Apply Button or
the Save Button&lt;/p>
&lt;p>In the Network tab you will see a new web request – select it:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage42.png"
style="width:5.40656in;height:2.82458in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977897" class="anchor">&lt;/span>Figure 26 Network Request
Sample&lt;/p>
&lt;p>What we are seeing here is the response from the call to Save the
properties. We can expand this response to view the complete JSON.&lt;/p>
&lt;p>By clicking on the Headers we can view the actual request:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage43.png"
style="width:5.125in;height:2.47222in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977898" class="anchor">&lt;/span>Figure 27 HTTP POST
Request for Saving Properties&lt;/p>
&lt;p>Here we can see that this will correspond to the APIs listed in
Glassworks.&lt;/p>
&lt;p>Most importantly the “Payload” tab is our definition of the body of the
request. This is provided in JSON format and can be expanded. As shown
here:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage44.png"
style="width:4.90769in;height:2.94205in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977899" class="anchor">&lt;/span>Figure 28 HTTP POST Body&lt;/p>
&lt;p>We now have the correct API call and the format of the body to
successfully make the API call. We can also see from the body that if we
wish to update properties in Onshape from our third-party application,
we need to store the propertyID value.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />It is important to mention –
ALWAYS use cad.onshape.com to make API calls (no matter what you see in
the Headers tab or is shown in the Payload tab.&lt;/p>
&lt;h3 id="define-an-application-extension">Define an Application Extension&lt;/h3>
&lt;p>An application extension is how Onshape embeds third-party application
features in its UI. There are two types of extension:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>An extension that embeds its UI from the application into the
Onshape UI in an iFrame. Such a application my call Onshape REST
APIs or just expose an application interface inside Onshape.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An extension that embeds and that calls a REST API exposed by the
application from the Onshape UI. For instance, embedding application
functionality in the context menus or toolbars. This type of
application extension relies on external OAuth information in order
to authenticate the call. In this case Onshape acts as the client
and the application as the server.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Each extension will exist at a specific location in the Onshape UI and
will work within the context of that location or a specific selection,
passing the relative information to the application.&lt;/p>
&lt;p>In order to define the Application Extension we return to the
development portal at &lt;a href="https://dev-portal.onshape.com/oauthApps">https://dev-portal.onshape.com/oauthApps&lt;/a> where
we initially defined our OAuth Application.&lt;/p>
&lt;p>Select the OAuth Application that you previously defined and click on
the Extensions tab.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage45.png" style="width:6.5in;height:3.37917in"
alt="Graphical user interface, text, application, Teams Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977900" class="anchor">&lt;/span>Figure 29 - Oauth
Applications - Extensions&lt;/p>
&lt;p>Start by clicking the “Add Extensions button.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note that you can create as
many extensions as you need for your application within the Onshape UI.&lt;/p>
&lt;p>This is the interface where you define where in the Onshape UI the
command will appear, and what endpoint in your application the command
will reference. Changing the Location dropdown will provide additional
fields that can be defined to specify context and other relevant fields.&lt;/p>
&lt;p>For our use case, Define a name, i.e. “Custom Part Number Generator”,
define a description of the extension and select “Part Number Generator”
from the Location dropdown. The only other field that you need to define
is the Action URL. This is the endpoint in your application where you
will fetch the part number from.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage46.png" style="width:4.125in;height:4.125in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977901" class="anchor">&lt;/span>Figure 30 - Define
Application Extension&lt;/p>
&lt;p>Once you save the definition you will see it in the list of extensions.
You can always come back and edit the definition of the extension.&lt;/p>
&lt;h3 id="grant-onshape-access-to-3suprdsup-party-data">Grant Onshape Access to 3&lt;sup>rd&lt;/sup> Party Data&lt;/h3>
&lt;p>If you require Onshape to access the resources of your application, then
you will need to define the external OAuth parameters. In our use case
we will need Onshape to access data in our application in order to pull
the part numbers into Onshape.&lt;/p>
&lt;p>Click on the External OAuth tab, the final tab on the OAuth Applications
page.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage47.png" style="width:6.5in;height:3.27361in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977902" class="anchor">&lt;/span>Figure 31 - Define
External OAuth&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />In this guide we’re not
detailing the implementation of OAuth2 inside your application, this is
explained very well in many on-line guides. My favorite of these can be
found at:
&lt;a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2&lt;/a>&lt;/p>
&lt;p>Onshape provides the fields that are required for it to make a secure
request to your application, receive an access Token and refresh it when
required. In this case Onshape acts as the client and your application
as the server – this is the inverse to what we defined when we enabled
the third-party application to access Onshape.&lt;/p>
&lt;p>Once you have defined the fields, Save/Update the definitions. We have
now completed defining the application extension and enabling Onshape to
access your applications resources.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Note if you haven’t defined
all the endpoints at this time, you can come back later and update the
information once you have it defined in your application.&lt;/p>
&lt;p>The last thing we need to do is for the user to grant access for Onshape
to access your applications resources. We can do this through the same
interface that we used to grant access to Onshape.&lt;/p>
&lt;p>From inside Onshape go to your account settings, from the top right
dropdown menu. Click on the applications page.&lt;/p>
&lt;p>For applications that have an application extension and External OAuth
defined we have the “Grant” button available in the “external Access”
column as shown here:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage48.png" style="width:6.5in;height:2.87083in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977903" class="anchor">&lt;/span>Figure 32 - Grant
External Access&lt;/p>
&lt;p>Click the “Grant” Button in the External Access column.&lt;/p>
&lt;p>Your third-party application will present the user with option to
authorize access to the application – similar to this simple interface:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage49.png"
style="width:4.25285in;height:1.71051in"
alt="Graphical user interface, text Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977904" class="anchor">&lt;/span>Figure 33 - Enabling
Onshape to access a 3rd parties data&lt;/p>
&lt;p>If you click “Allow”, you will be returned to Onshapes Applications page
and external access will be granted.&lt;/p>
&lt;h3 id="defining-webhooks">Defining Webhooks&lt;/h3>
&lt;p>Now that we’ve defined our application extension and OAuth access to our
application, we can start on receiving notifications in our application
when events happen in Onshape.&lt;/p>
&lt;p>Onshape supports webhook notification for many different types of
events. We will register an endpoint in our application that will
receive a notification whenever something occurs in Onshape. In our
specific scenario this will be when the user updates the Onshape
properties – as we defined in &lt;strong>Step 1 Define Properties in Onshape&lt;/strong>:&lt;/p>
&lt;p>For our purposes we will be registering to receive web hook
notifications for the onshape.model.lifecycle.metadata event. When
registering for an event in Onshape there are only two pieces of
information required:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The event (onshape.model.lifecycle.metadata)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Enterprise ID&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>To easily find your enterprise ID, in Onshape select the Enterprise
Settings option from the top right dropdown menu and then click on the
“Details” menu option on the left-hand menu bar.&lt;/p>
&lt;p>You will see your Enterprise ID and a “Copy to Clipboard” button next to
it. This will enable you to directly copy this unique ID into your code.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage50.png"
style="width:3.0006in;height:2.70759in"
alt="Graphical user interface, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977905" class="anchor">&lt;/span>Figure 34 - Finding Your
Enterprise ID&lt;/p>
&lt;p>The following code shows how we can register a webhook in Onshape.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage51.emf" alt="">In this example I’ve hard-coded a few of
the values for clarity, however this method could be re-written to be a
generic model for registering various webhooks. Some good examples of
registering for webhooks exist at &lt;a href="https://github.com/onshape-public">https://github.com/onshape-public&lt;/a>.&lt;/p>
&lt;p>As with other calls to Onshape that we’ve seen, we are passing the
accessToken in the header in order to establish a secure call to
Onshape’s resources.&lt;/p>
&lt;p>The information coming back from the registration call will be similar
to the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;2014-12-16T23:45:10.611-0500&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;event&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;webhook.register&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;workspaceId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;elementId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;webhookId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;544e91f7fb88ed44f5de1508&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;messageId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;34795d2e5f5f44eeb61fb7b1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;data&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;Some data&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;documentId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;versionId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In our example we are saving the event
(onshape.model.lifecycle.metadata) and the returned webhookId to a
database in order that we can later ping it to make sure that it is
live.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Following the registration of
the webhook, Onshape will attempt to make a call to the Notify URL
defined in the body of the registration request. This is the endpoint of
your application that should be called when the event is fired in
Onshape. The most common reason for registration failures is that the
endpoint you defined, does not return an HTTP 200 status code.
Therefore, even if you registered for an event and received a
registration notification and a webhookId back from Onshape, your web
hook is not in fact registered until Onshape validates the notify URL
and receives the HTTP 200 notification back from it. Unfortunately there
is no way to easily know if your web hook has been successfully
registered until you either ping it, request to list it, or try to
activate the event through Onshape.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Also it is important to know
that even when your webhook is registered successfully, if you change
your code later on and Onshape fails to receive an HTTP 200 status code
back from the notify URL, the web hook will be removed.&lt;/p>
&lt;p>One of the ways we can validate that a webhook is “live” is by pinging
it using the Onshape REST API. The following code shows the
implementation of a ping to the webhook. If an HTTP status code of 200
is returned, we know that the webhook is enabled, if not then we can
re-register the webhook as needed.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />&lt;img src="https://onshape-public.github.io/images/integrationguideimage52.emf" alt="">Once
we store the webhook ID in the database we can ping the webhook whenever
the application is loaded and validate that it’s still registered. If we
need to re-register the webhook (usually only occurs when changes are
made to the code in the notify URL), we can create a new webhook
registration and update the database record.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Note that you can create many
duplicate webhook registrations for the same event with the exact same
notify URL. Onshape doesn’t limit how many registrations are created for
a single webhook. In the event that this happens, the notify URL will be
called as many times as there are webhooks registered for that event.
You can validate the registered webhooks by calling the
&lt;strong>&lt;a href="https://cad.onshape.com/api/webhooks">https://cad.onshape.com/api/webhooks&lt;/a>&lt;/strong> API.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Use
&lt;a href="https://cad.onshape.com/glassworks">https://cad.onshape.com/glassworks&lt;/a> to call APIs and validate the
requirements for each REST API call. This interface lists all the
available Onshape REST APIs and provides examples of the values returned
from each call.&lt;/p>
&lt;h3 id="receiving-webhook-notifications">Receiving Webhook Notifications&lt;/h3>
&lt;p>Once your webhook is registered and confirmed to be working you should
be getting a notification from the webhook to your notify URL. The
notification should be similar to the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;2014-12-16T23:46:29.284-0500&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;event&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;onshape.document.lifecycle.metadata&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;workspaceId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;elementId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;webhookId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;544e91f7fb88ed44f5de1508&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;messageId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;60f54ac1cbc04179a6642d9a&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;data&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;Some data&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;documentId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;0f9c4392e5934f30b48ab645&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;versionId&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;000000000000000000000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1e90ff;font-weight:bold">&amp;#34;documentState&amp;#34;&lt;/span>: &lt;span style="color:#a50">&amp;#34;IN PROGRESS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In your case the workspaceId, elementID, documentID, and PartId should
be populated with the values from the Onshape document that was open
when the properties were updated.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />It is important to note that
there is currently no OAuth validation on the webhook response,
therefore the endpoint in your application will not receive any access
token data for directly calling Onshape APIs. Therefore, if you need to
make a call to the Onshape REST APIs inside the notify URL endpoint make
a call to an endpoint in your application and include your application
OAuth credentials in the body of the request. In this way, you can make
a call to your application and load the passport and the Onshape
credentials.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Onshape takes security very
seriously and for this reason, unauthenticated calls only provide
minimal details such aa, in this case, id’s.&lt;/p>
&lt;h3 id="getting-onshape-properties">Getting Onshape Properties&lt;/h3>
&lt;p>In our specific use case, when we received the webhook notification, we
want to use the ID data provided to find the corresponding object in our
database (or create a new one) as shown in Step 2 Create Corresponding
Object: Then we make a call to the Onshape REST API:
/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/{iden}/{pid}&lt;/p>
&lt;p>All the relevant data is provided in the response from the webhook so we
can pass this to the method which will call this API as follows:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage53.emf" alt="">From this call I am returning the
“properties” part of the JSON – this contains all the metadata
definitions that I wish to store in my database and associate with the
corresponding object. The following is an example of one of the property
objects:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage54.emf" alt="">&lt;/p>
&lt;p>In fact there is probably only three key pairs that we’re interested in
here:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Name – name of the property. In this case “Name”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Value – the value of the property. In this case “Top Plate”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>propertyId – the ID of this property. We might need this if we want
to enable a bi-directional sync between both applications.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Note that for valueType
CATEGORY the actual name, value and id will be embedded deeper in the
object inside an array. I suggest copying and pasting the output from
the API call into a JSON viewer such as &lt;a href="http://jsonviewer.stack.hu/">http://jsonviewer.stack.hu/&lt;/a> so
that it will be easier to find where the correct values are.&lt;/p>
&lt;p>We can now update our corresponding object with the Onshape metadata
values as described in Step 3 Get Onshape Metadata:&lt;/p>
&lt;h3 id="updating-onshape">Updating Onshape&lt;/h3>
&lt;p>So far we have pulled data from Onshape and populated it into our
third-party application, however what if we make updates in our
application that we want to propagate back to Onshape? This is certainly
possible through Onshape’s REST API. Usually this would be implemented
in your application on the click of a button – such as “Save”, if you
have multiple properties to update, or when a property is updated if you
want to trigger the sync for the update of a specific field.&lt;/p>
&lt;p>Either way it is fairly straight forward to send the REST API call to
Onshape to update properties. The following snippet of code shows how
the call can be made:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage55.emf" alt="">As we can see here, we provide the body in
the form of JSON that includes an array of items (in this case one item)
and a nested array of properties (two property objects are listed here).
Each property has a value and an ID of the property in Onshape to
update.&lt;/p>
&lt;p>The response from this API call should be an HTTP 200 status. If this is
the case, we can update the user that the sync was successful.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />If you know that you want to
update Onshape with property values from your application, it will be
important to build a data model that can store the properties with the
unique ID provided by Onshape.&lt;/p>
&lt;h3 id="implementing-custom-part-numbers">Implementing Custom Part Numbers&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage56.png"
style="width:2.95556in;height:2.94924in" />&lt;/p>
&lt;p>The final step in this
business case is to pull the part numbers form our third-party
application. The part numbers can be calculated based on metadata values
that were previously synced from Onshape or they might be numbers being
pulled from yet another system – such as an ERP or even a Google
Spreadsheet. The important thing is that when the user clicks a button
in Onshape, the correct Part Numbers get populated.&lt;/p>
&lt;p>To first understand how the setup for pulling part numbers from a
third-party application we need to go back to the definition of our
Application Extension in the Onshape developer’s portal.&lt;/p>
&lt;p>Here we can see that we gave the application extension a name, defined
the location as “Part Number Generator” and defined the “Action URL” –
this is the endpoint in our application where we will fetch the part
number from.&lt;/p>
&lt;p>Once we have the application extension defined as Location = Part Number
Generator, you will be able to use this option inside Onshape Release
Management settings.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage4.png"
style="width:0.43056in;height:0.43056in" />Note that in order to use the
Part Number Generator option you will have to define the External OAuth
option and grant Onshape access to the resources of your application.
This is because Onshape will need to access the defined endpoint in
order to pull the part number from the application&lt;/p>
&lt;p>From within Onshape Select the “Enterprise Settings” from the top right
dropdown menu. Navigate to the “Release Management” settings and scroll
down to the “Revisions and part numbers” section of the page.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage57.png"
style="width:4.05994in;height:3.27831in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977907" class="anchor">&lt;/span>Figure 36 - Revisions and
Part Number Settings&lt;/p>
&lt;p>In the Part Number Generation dropdown select the “Custom Part Number
Generator”. Note that this is the name that you defined in your
Application Extension so it might differ from what’s shown here.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage58.png"
style="width:2.73732in;height:2.03131in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977908" class="anchor">&lt;/span>Figure 37 - Selecting
Custom Part Number Generator&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage6.png"
style="width:0.47222in;height:0.47222in" />Finally scroll to the bottom
of the page and save the settings.&lt;/p>
&lt;p>Note that you will need the Admin role in order to access the enterprise
settings.&lt;/p>
&lt;h3 id="implementing-part-number-code">Implementing Part Number Code&lt;/h3>
&lt;p>Onshape will send a message to the endpoint defined in your application
extension settings. The content of this message will be an array of the
following data.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage59.emf" alt="">There might be one or more object depending
upon where the user initiated the call for part numbers from. For
instance, if the call was initiated from the Part properties window,
there will only be one object, however if initiated from the release
candidate window, multiple parts/assemblies and drawings might be
requested in the single call. Therefore, your code should be able to
handle these two situations.&lt;/p>
&lt;p>Onshape will expect a response back from your endpoint and it should be
formatted in the following manner:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage60.emf" alt="">Note that in fact only the id and
partNumber fields are actually required – the other fields are optional.&lt;/p>
&lt;p>The following is an implementation of the getNextPartNumber endpoint
that was defined in the application extension “Action URL” field:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage61.emf" alt="">This in turn calls a function that pulls
the next part number from the corresponding object in the database (this
was defined in, Step 5: Request Part Number). In this function I’m
defining the object that will be sent to Onshape with the part number.
This will be called multiple times depending how many objects were sent
from Onshape.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage62.emf" alt="">In this case I’m sending back all the data
required by Onshape, however it would be enough to just populate the id
and the partNumber.&lt;/p>
&lt;p>Once you load the Part Properties window or the Release candidate
window, you can now request the Next Part number. The part number will
be pulled from the third-party application and populated in the relevant
fields as shown below.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage63.png"
style="width:4.59649in;height:3.80143in"
alt="Graphical user interface, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977909" class="anchor">&lt;/span>Figure 38 - Release
Candidate Part Number generation&lt;/p></description></item><item><title>Docs: Sync Releases and Revisions</title><link>https://onshape-public.github.io/docs/tutorials/releases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://onshape-public.github.io/docs/tutorials/releases/</guid><description>
&lt;p>This tutorials builds off the &lt;a href="https://onshape-public.github.io/docs/tutorials/sync">Sync Data and Metadata&lt;/a> tutorial. Please complete that one before starting on this one.&lt;/p>
&lt;p>In this case, we’ll be looking at the ability for Onshape to sync its
release data with an external system and for that system to send
information back to Onshape with regards to released data.&lt;/p>
&lt;p>This specific business case will look at what happens when you wish for
a PLM system to control the release of data instead of Onshape having
that control – this is in fact a common use case.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage64.png"
style="width:3.21077in;height:2.56522in" />&lt;/p>
&lt;p>We have mentioned before that
Onshape has the ability to release data – it is totally integrated to
Onshape since there is no division between CAD capabilities and PDM
capabilities in Onshape – they are all part of the same solution. See
Versions and Releases for more information on how Onshape manages
releases. There is importance in releasing data through Onshape. Onshape
uses visual cues to show which parts are released in an assembly for
instance and which parts might have a newer revision. Onshape can also
add/remove watermarks to drawings and update the title block depending
on release states. Also, the BOM table can pull a parts release data and
display it. All this is dependent upon a release process being completed
in Onshape.&lt;/p>
&lt;p>Many organizations have implemented Product Lifecycle management systems
(PLM). One of the key benefits of a PLM system is that it manages more
than just engineering data originating from the engineering department,
it deals with all the data related to the product – from concept through
retirement. Therefore, it is a system that is used by many groups and
departments throughout the organization.&lt;/p>
&lt;p>Often, in release processes or Engineering Change processes, additional
input and approvals are required from various departments downstream
from engineering. PLM systems are very good at routing the data for
approval to users from multiple departments and groups throughout the
organization. Onshape, on the other hand, is very focused on the
engineering department and the data generated there. While it certainly
has the capabilities to bring other groups into approval processes, it
is not considered a process centric enterprise-wide system with the
capabilities of a PLM system.&lt;/p>
&lt;p>Many companies will have well established processes that have been
modeled in their PLM system, it is much easier for us to integrate into
those processes than reinvent the wheel in Onshape.&lt;/p>
&lt;p>This section looks at how we might have the best of both worlds,
initiate release processes in Onshape and update our Onshape visual cues
as well as have the PLM system manage the actual approvals and release.&lt;/p>
&lt;p>This section uses concepts such as OAuth and web hooks that we have
introduced in detail in previous sections, therefore feel free to
reference those sections for more information on these topics.&lt;/p>
&lt;h3 id="step-1-initiate-release">Step 1: Initiate Release&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage65.png"
style="width:4.88889in;height:2.02778in"
alt="Application Description automatically generated" />&lt;/p>
&lt;p>In this first step we are using Onshape’s out-of-the-box capabilities to
initiate a release candidate – just as we would if we were releasing
natively in Onshape.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>We start by initiating the release on all the data that is required.
In this step you should use a custom workflow that simply has one
approval node.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Define the mandatory and any other release properties in the release
candidate window. &lt;img src="https://onshape-public.github.io/images/integrationguideimage66.png"
style="width:4.70609in;height:3.12281in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;span id="_Toc102977911" class="anchor">&lt;/span>Figure 40 - Initiating a
release candidate&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>Since an approver is required, we must provide a fictious
user/approver that has been defined in the system – this could be
named “Release Approver” for instance. The process will be sent to
this approver even though they are not a real person and will not be
able to approve the release. Instead, our release process will be
approved by an external source.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Finally, when everything is defined, submit the release. The window
will close. Since the release is pending approval, the parts
involved in the release will enter the state of “Pending” as shown
here:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage67.png"
style="width:4.40131in;height:2.9375in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;span id="_Toc102977912" class="anchor">&lt;/span>Figure 41 - Pending
Release&lt;/p>
&lt;p>They will remain in this state until the release has been completed.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage68.png"
style="width:2.71208in;height:1.52174in" />&lt;/p>
&lt;p>It is important to note that
unlike traditional PDM systems where the files are locked for change
until the release is completed or rejected, Onshape does not lock the
files. As mentioned previously, Onshape views the releases as a point in
time. As far as Onshape is concerned, time moves forward, parts can
change and at a specific point in time, the parts are in a state of
pending. It is important to mention that this does in fact prevent
another release from being initiated on the parts until the previous
release has been completed.&lt;/p>
&lt;h3 id="step-2-initiate-release-process-in-3suprdsup-party-app">Step 2: Initiate Release Process in 3&lt;sup>rd&lt;/sup> Party App&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage69.png"
style="width:5.34722in;height:3.34722in"
alt="Diagram Description automatically generated" />&lt;/p>
&lt;p>Once the user initiates the release candidate and the parts transition
to the “pending” state we can register for a webhook that will notify
our third-party application that the parts have changed state.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Once the parts enter the workflow, the onshape.workflow.transition
webhook will be triggered.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Our third-party application should be listening for this event along
with other data, we are provided with the objectId of the release
package – this is all the data associated with the parts that are to
be released. The response also contains the objectType and the
transitionName; for our use case we will only concern ourselves with
requests that have an objectType of “Release” and a transitionName
of “Submit”.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Using the ObjectId we make an API call to onshape;
/api/releasepackages/&amp;lt;releasePackageId&amp;gt;?detailed=true&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This API call will return to us a JSON response containing all
assemblies and parts in the release package. The following
information should be extracted from the release package:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>For each line item (assembly or part) extract the documentId,
the elementId, elementType, versionId and PartId&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Iterate through the top level properties and record the
propertyId for property with the name “comment” – this will be
used to update the release comments later on.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Now that we have the relevant IDs we can update the state of our
corresponding objects in the third party system and record any
additional data such as the release comment field.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Finally, we can kick off our official release process in the
third-party application. This could be an automated process or a
manual one.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="step-3-complete-release-process">Step 3: Complete Release Process&lt;/h3>
&lt;p>The release process continues in the third-party application until
approvals have been received by all required actors. Meanwhile in
Onshape the parts are in the pending state. In this step we close the
loop once the release process is completed.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage70.png"
style="width:5.375in;height:3.34722in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The release process managed by the third-party application is
completed and the data in that system is released.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Once this happens, we make a call to the Onshape API;
/api/releasepackages/&amp;lt;releasePackageId&amp;gt; the releasePackageId is
the ID we were provided with at the start of this process – While
there are different ways of implementing this, I tend to store the
ID and any other data related to the release in a custom “release
Object” in my database so I can retrieve and update the release as
required. In addition to the passing the release package ID, in the
body of the request we should pass the id of the release comment and
a value for the comment. This will update the release in Onshape
with any relevant data.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Onshape releases the data that was included in the release candidate
and that completes the workflow process.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Onshape will return a status code that indicates success or failure&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Finally we can optionally update the corresponding object to
indicate that it is in sync with the Onshape data.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>In the event that the release process is rejected at anytime, we can
send the releasePackages API request to Onshape with a REJECT workflow
Action argument. This will cause Onshape to reject the workflow and the
state of the parts at the specific release point in time, will be set to
“Rejected”.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage71.png"
style="width:4.69737in;height:3.12807in"
alt="Graphical user interface, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977914" class="anchor">&lt;/span>Figure 43 - release
candidate rejected&lt;/p>
&lt;p>Since our timeline is moving forward this has no actual effect on the
parts other than to cancel the pending release and enable them to be
released at another future point in time.&lt;/p>
&lt;h2 id="implementation">Implementation&lt;/h2>
&lt;p>In this section we will take a closer look at how to implement the
release scenario in our code. The first thing we need to do is define
the correct web hook to listen for the initiation of the release – this
means that once the user clicks the submit button on the release
candidate dialog, this web hook will be triggered.&lt;/p>
&lt;h3 id="set-up-webhook">Set Up Webhook&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage72.emf" alt="">&lt;/p>
&lt;p>This code is very similar to what we defined previously for the metadata
update, instead here we are defining a hook for the
onshape.workflow.transition hook. As with other code examples that
require authentication, we have included error handling in order to
refresh that access token in the event that it has expired.&lt;/p>
&lt;p>The onshape.workflow.transition will in fact fire whenever a revision or
release package transitions through different workflow states. In his
specific case we are only interested in catching the event when the
workflow is initially submitted. This can be filtered by the information
sent to the return URL, in this case
&lt;a href="https://myserver.com/api/getReleaseData">https://myserver.com/api/getReleaseData&lt;/a>&lt;/p>
&lt;p>In this implementation we are storing he webhook ID in the database so
that we can ping it when the application is loaded to make sure that it
is still active. Other implementations delete the webhook after it is
used and then recreate it as required. There is no specific preference
for which methodology is better – that depend s upon the requirements of
your integration.&lt;/p>
&lt;h3 id="receive-web-hook-notifications">Receive Web Hook Notifications&lt;/h3>
&lt;p>Once the user who is initiating the release clicks the Submit button on
the Release Candidate dialog, the webhook will be triggered and a
message will be sent to the third-party application listening for that
webhook.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage66.png"
style="width:4.70609in;height:3.12281in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>In our example the URL that the webhook data from Onshape gets sent to
is:&lt;/p>
&lt;p>&lt;a href="https://myserver.com/api/getReleaseData">https://myserver.com/api/getReleaseData&lt;/a>&lt;/p>
&lt;p>In our application we can define a router for that end point as follows:&lt;/p>
&lt;p>router.route(&amp;rsquo;/getReleaseData&amp;rsquo;).post(mymodule.getReleaseData);&lt;/p>
&lt;p>In this case “mymodule” is where I’ve defined all the functionality for
managing data coming from Onshape. Since the webhook data contains no
authentication information (just minimal data is sent from the webhoom
for security reasons), we can’t directly authenticate our application
against Onshape, therefore we need to pass the data received from the
webhook through a method that will then add the authentication data to
our request object. The getReleaseData method simply passes the webhook
information received by the application to another authenticated
endpoint as follows:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage73.emf" alt="">&lt;/p>
&lt;p>Here is the endpoint defined for processReleasePackage:&lt;/p>
&lt;p>router.route(&amp;rsquo;/processReleasePackage&amp;rsquo;).post(authController.isAuthenticated,
releaseController.processReleasePackage);&lt;/p>
&lt;p>As we can see here, we have now added in the authentication middleware -
authController.isAuthenticated - and can make secure calls to Onsahpe’s
API.&lt;/p>
&lt;h3 id="get-release-package-data">Get Release Package Data&lt;/h3>
&lt;p>The parameter that the web hook sent over to our application that we
need to make use of is the ID of the release package. We can now make a
call to Onshape to retrieve the complete release package with the ID.&lt;/p>
&lt;p>We get the release package ID from the request object and make the REST
API call to get the package as follows:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage74.emf" alt="">&lt;/p>
&lt;p>The complete release package should be returned in “response”. We can
now parse that data to retrieve the properties we need. The most
important properties will the IDs of the parts that we are going to
release – these should already be synced with our system – if not, we
can create them from the data in the release package.&lt;/p>
&lt;h3 id="save-release-package-data">Save Release Package Data&lt;/h3>
&lt;p>The next step is to save the properties of the release package to a
corresponding object in our database. We need at least the ID of the
release package so we can later release it automatically from the
third-party application. In this case I’m storing other properties that
came from the release candidate such as release name and description.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage75.emf" alt="">&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage76.png"
style="width:3.01875in;height:4.38889in" />&lt;/p>
&lt;p>Most of this code deals with
retrieving values from the release package and storing them as a new
release object in the database. Additional values are associated with
the part in the PLM system. In a typical production scenario this code
would interface with the PLMs workflow capabilities and possibly kick
off a release or change process in that system. For our basic example we
are storing values from Onshape with our items and setting a state on
the part so that users can see that the part is pending release and take
actions required.&lt;/p>
&lt;p>At this point in time, Onshape does not care that the part is pending a
release. The part in Onshape will remain in a pending state until it is
released by the PLM system. As noted previously, we used a user setup in
the system to specifically initiate the release, therefore no other
users will receive notifications from Onshape with regards to release
actions on this part.&lt;/p>
&lt;h3 id="complete-the-release">Complete the Release&lt;/h3>
&lt;p>Once the release or change workflow has completed in the PLM system and
all approvals have been received, the Part/Item will be in a released
state in the PLM system. However, we must now update Onshape with the
correct release status of the parts. It is important that Onshape data
is in sync with the corresponding data in the PLM system for reasons of
data integrity and the visual cues used within Onshape to identify a
part as released.&lt;/p>
&lt;p>In a typical scenario Onshape will be automatically updated once the
workflow completes in the PLM system. In our use case we are simplifying
the process by clicking a button to release the item. This will update
the state of the part in our system and send a REST API call to Onshape
to release the data in the release package (be it one part, an assembly
with multiple parts, or drawings).&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage77.emf" alt="">&lt;/p>
&lt;p>This code snippet updates the database with the released status of a
part. Since we stored data from the release package in our database we
now retrieve the “Comment” property so that we can send an updated value
to Onshape with the release.&lt;/p>
&lt;p>let attrid = rp.props.find(ob =&amp;gt; ob.name == &amp;ldquo;Comment&amp;rdquo;);&lt;/p>
&lt;p>The important line of code here is the REST API call to Onshape:&lt;/p>
&lt;p>&lt;strong>axios.post(&amp;lsquo;&lt;a href="https://cad.onshape.com/api/releasepackages/'">https://cad.onshape.com/api/releasepackages/'&lt;/a> + id +
&amp;lsquo;?wfaction=RELEASE&amp;rsquo;&lt;/strong>&lt;/p>
&lt;p>The id provided here is the ID of the release package that we stored
when the web hook was called at the beginning of the process. The
“wfaction” argument indicates that the workflow action in Onshape should
be to release the data associated with this release package.&lt;/p>
&lt;p>In this example we are also updating the release comments in Onshape,
for this reason we required the property ID of the Comment field – which
we also previously stored in our release object in the database.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage78.png" style="width:6.5in;height:4.25903in"
alt="Graphical user interface, text, application Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977916" class="anchor">&lt;/span>Figure 45 - Release
completed automatically in Onshape&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage79.png" style="width:6.5in;height:4.25625in"
alt="Graphical user interface, text, application, email Description automatically generated" />&lt;/p>
&lt;p>&lt;span id="_Toc102977917" class="anchor">&lt;/span>Figure 46 - Release
comments Updated from third-party system&lt;/p></description></item><item><title>Docs: Generate Derivative Files</title><link>https://onshape-public.github.io/docs/tutorials/derivative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://onshape-public.github.io/docs/tutorials/derivative/</guid><description>
&lt;p>This tutorials builds off the &lt;a href="https://onshape-public.github.io/docs/tutorials/releases">Sync Releases and Revisions&lt;/a> tutorial. Please complete that one before starting on this one.&lt;/p>
&lt;p>It’s clear by now that Onshape doesn’t use files to store its data,
instead it is a data driven solution that is always up to date. Files
are a snapshot in time that provide a view of the design at a specific
point in time - such as at a release or version. A new file is required
for each “snapshot” and managing these files can get quite cumbersome.
However, there are situations that require that files be generated from
the Onshape data.&lt;/p>
&lt;p>In general, we want files to be generated at defined points of time and
within the context of a business process – such as a release process.
The derived file could be a format such as a PDF of the drawing that is
generated following the successful release of the data. Also, a common
requirement is to generate STEP files or JT files that can be used in 3D
Printing or viewers embedded in PLM solutions. Regardless of the use
case Onshape has very good export capabilities for many different file
formats.&lt;/p>
&lt;p>This business case examines how to automatically generate files derived
from the Onshape data. The process described here can be plugged into
many different use cases. In this specific example we are plugging the
translation use case into the Release Business case just after the
release is completed in the third-party application and Onshape is
updated. Since we already have all the relevant ID information for the
parts to translate from the release package data, we can directly call
the translation APIs after receiving notification that the release was
successfully executed in Onshape.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage80.png"
style="width:5.5in;height:4.79167in" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Once we have received an HTTP 200 status from the call to Onshape to
release the release Package, we can proceed with the translation.
The reason why we may want to wait till the release has successfully
completed could be for several reasons:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>We are generating a PDF of the drawing and want the “In
Progress” watermark removed, and the title block updated with
release information&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We are generating files for 3D printing or for sending to a
vendor to manufacture and we only want to send released data&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>We can now make an API call to Onshape. In both the following cases
we must pass the document Id, the version Id and element Id – all
values that were available in the release package. Other values are
dependent upon your specific use case and can be referenced in
&lt;a href="https://cad.onshape.com/glassworks/explorer/#/PartStudio/createPartStudioTranslation">https://cad.onshape.com/glassworks/explorer/#/PartStudio/createPartStudioTranslation&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>For Assembly translation we can POST to :/api
/assemblies/d/{did}/{wv}/{wvid}/e/{eid}/translations.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>For Parts we can POST to:
/api/partstudios/d/{did}/{wv}/{wvid}/e/{eid}/translations&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Three variables of importance are returned from the API call to
translate: requestState, id (of the translation) and
resultExternalDataIds. We should store or keep this data in memory
until the translation is completed. Depending upon the requestState
there might be additional data available in the response.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We can now periodically ping the translation web service with the id
retrieved in the last step. Using the GET call to
/api/translation/{id} we will receive one of three responses in the
requestState:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>DONE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ACTIVE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FAILED&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Depending on the response we can either continue to periodically
ping the translation service if we received ACTIVE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Notify the user of a failed translation attempt if we received a
FAILED response&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Make a call to Onshape to GET the translated file if we received a
DONE response. To retrieve the translated file make a GET request to
/api/documents/d/{documentId}/externaldata/{externalDataId}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The file can now be stored in your third-party system or stored to
an external drive depending upon your specific use case.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="implementation">Implementation&lt;/h2>
&lt;p>As use cases go, this is a very straightforward process. The only
complexity here is deciding how to receive the notification from Onshape
that the translation has completed. There are several ways of
implementing this including using a webhook to notify us when the
translation completes. In the examples here I will show both the webhook
methodology as well as pinging Onshape with a status request every
couple of seconds. The status request can be initiated from the client
through an AJAX call or, as in the example I use here, from the server.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage81.png"
style="width:3.3395in;height:3.66667in" /> In our example I have added a
button to the interface of my third-party system that enables me to
request a translated file. In this use case I have hard coded that the
resulting file should be a STEP file – in a production ready
implementation, we would expect that one or more formats are available
and possibly selected by the user. In addition, a production ready
implementation might have automated the translation for whenever a part
is released. Other considerations for automation might include
identifying what is being released. I.e. if it’s a part then translate
to STEP, if it’s a Drawing then translate to PDF, etc. These are all
very common use cases.&lt;/p>
&lt;h3 id="initiate-the-translation">Initiate the Translation&lt;/h3>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage82.emf" alt="">The code snippet shown here is fairly
straightforward. First it gets the ID of the part that was sent from the
client, it then uses that ID to retrieve the part from the database. The
part stored in our database already has all the required values to
successfully communicate with Onshape, such as the document ID, the
workspace ID and the element ID – all these values are used in the
translation request.&lt;/p>
&lt;p>In the body of the request we can see some of the required values that
define how the part is to be translated to STEP. In this case I have
only included the minimum required key pairs for this translation.&lt;/p>
&lt;p>The REST API call to translate an Onshape element returns an object that
includes the translationId – this is the value that will be used to ping
Onshape and request the status of the translation.&lt;/p>
&lt;h3 id="ping-onshape-for-translation">Ping Onshape for Translation&lt;/h3>
&lt;p>In this code snippet I have simplified things by including a function
that waits for a second and then pings Onshape again, It will continue
pinging Onshape until it receives back a status that is not “ACTIVE”.
Once the status returned is anything except “ACTIVE” it returns the
resulting object back to the client.&lt;/p>
&lt;p>The id used here is the translationId retrieved from the result object
when the translation was initiated.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage83.emf" alt="">&lt;/p>
&lt;p>Once the requestState is changed, this will indicate that the
translation has completed either with a FAIL or a DONE status. Depending
on the result we can define our logic on the client appropriately.&lt;/p>
&lt;p>The following shows the object returned to the client from the
translation REST API. Note that the requestState is now set to “DONE”,,
meaning that the translation has completed
successfully.&lt;img src="https://onshape-public.github.io/images/integrationguideimage84.png" style="width:6.5in;height:3.17986in"
alt="A picture containing timeline Description automatically generated" />&lt;/p>
&lt;p>With this data we can now request the file directly from Onshape. The ID
that we need to use to retrieve the file is the “resultExternalDataIds”.
Note that this is an array of values – since it makes sense that we
might be translating more than one part.&lt;/p>
&lt;h3 id="retrieve-translated-file">Retrieve Translated File&lt;/h3>
&lt;p>With the resultExternalDataIds we can now retrieve the translated file
from Onshape. The following code snippet does exactly this.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage85.emf" alt="">&lt;/p>
&lt;p>The Onshape REST API&lt;/p>
&lt;p>&lt;a href="https://cad.onshape.com/api/documents/d/'">https://cad.onshape.com/api/documents/d/'&lt;/a> + did + &amp;lsquo;/externaldata/&amp;rsquo; + id&lt;/p>
&lt;p>retrieves the translated file – in this case the ID is
resultExternalDataIds[0] value.&lt;/p>
&lt;p>Once this is completed, we use the response to save the file directly to
our server where the application is hosted. Finally, I’m sending a JSON
object to the client that provides a direct link to the file that is now
hosted on our server.&lt;/p>
&lt;p>The client can then request the translated file from our server, even
though this is a function of the server and not related to Onshape, I
have included a code snippet here that will send the file to the client.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage86.emf" alt="">&lt;/p>
&lt;p>In our sample implementation Once the translation has completed
successfully I display a link to the translated file that calls the
“getfile” endpoint shown above.&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage87.png" style="width:6.5in;height:2.32917in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />&lt;/p>
&lt;p>Clicking the link will cause the file to be downloaded as shown here.&lt;/p>
&lt;h3 id="define-translation-webhooks">Define Translation Webhooks&lt;/h3>
&lt;p>As we mentioned at the beginning of this section there is more than one
way to receive notification back from Onshape that the translation has
completed. We can also define a webhook that will notify us once the
translation completes. The drawback with this methodology is that the
webhook must be created for each translation and then deleted.&lt;/p>
&lt;p>A complete example of this can be found at:
&lt;a href="https://github.com/onshape-public/app-gltf-viewer/blob/main/services/webhook-service.js">https://github.com/onshape-public/app-gltf-viewer/blob/main/services/webhook-service.js&lt;/a>&lt;/p>
&lt;p>The following function is used in this application to define the
webhook:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage88.emf" alt="">&lt;/p>
&lt;p>The following line would call this function once the user requests to
initiate a translation.&lt;/p>
&lt;p>WebhookService.registerWebhook(req.user.accessToken,
req.session.passport.user.id, did)&lt;/p>
&lt;p>Finally the endpoint registered with the webhook could be defined as
follows:&lt;/p>
&lt;p>&lt;img src="https://onshape-public.github.io/images/integrationguideimage89.emf" alt="">&lt;/p>
&lt;p>In this case once the translation is completed, this endpoint receives a
notification. If the event is equal to&lt;/p>
&lt;p>onshape.model.translation.complete&lt;/p>
&lt;p>We can assume that the translation has completed and we can unregister
the webhook and retrieve the translated file.&lt;/p>
&lt;p>The complete sample including it setup and deployment can be found at:
&lt;a href="https://github.com/onshape-public/app-gltf-viewer">https://github.com/onshape-public/app-gltf-viewer&lt;/a>&lt;/p></description></item><item><title>Docs: Create an Extension</title><link>https://onshape-public.github.io/docs/tutorials/createextension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://onshape-public.github.io/docs/tutorials/createextension/</guid><description>
&lt;p>In this example, you will create a custom web page (as shown in the image below) that is displayed in the
right-hand fly-out panel. This interface displays metadata pulled from
a third-party system when a part in Onshape is selected. This interface can also update metadata in Onshape through the &lt;code>Update&lt;/code> functionality.&lt;/p>
&lt;p>You can follow along with the steps below with this video:
&lt;a href="https://onshape.wistia.com/medias/0ivxxngkjz?embedType=async&amp;seo=false&amp;videoFoam=true&amp;videoWidth=640&amp;wvideo=0ivxxngkjz)">&lt;img src="https://onshape-public.github.io/images/ExtensionsVideoCard.png" style="width:5in" alt="OAuth app creation video"/>&lt;/a>&lt;/p>
&lt;h3 id="define-the-extension">Define the extension&lt;/h3>
&lt;p>This tutorials builds off the &lt;a href="https://onshape-public.github.io/docs/tutorials/derivative">Generate Derivative Files&lt;/a> tutorial. Please complete that one before starting on this one.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Navigate to the Developer portal from &lt;a href="https://dev-portal.onshape.com">https://dev-portal.onshape.com&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Click &lt;strong>OAuth applications&lt;/strong> in the left menu.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Select your application, and the click the &lt;strong>Extensions&lt;/strong> tab.
&lt;img src="https://onshape-public.github.io/images/integrationguideimage91.png" style="width:6.5in;height:3.48958in" alt="Graphical user interface, application, Teams Description automatically generated" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Click the &lt;strong>Add Extension&lt;/strong> button on the top right.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Select &lt;code>Element Right Panel&lt;/code>.
&lt;img src="https://onshape-public.github.io/images/integrationguideimage92.png" style="width:5.05785in;height:5.66469in" alt="Graphical user interface, application Description automatically generated" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Next, define the context. The context defines what parameters
can be sent from Onshape to the application. Some basic
parameters are automatically sent with any context, additional information can be passed to our
application, depending on the context selected. Click the &lt;code>Selected part&lt;/code> option. This sends the &lt;code>partId&lt;/code> and &lt;code>partNumber&lt;/code> to the application, along with the &lt;code>documentId&lt;/code>, &lt;code>elementId&lt;/code>, and the &lt;code>workspaceOrVersionId&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>In the &lt;code>Action URL&lt;/code> field, fill in the URL of the page to load in the right element panel. The parameters can be added as arguments (variable that get replaced with real values when the page is loaded from Onshape).&lt;/p>
&lt;pre tabindex="0">&lt;code>https://ourserver.com/bom?documentId=${documentid}&amp;amp;elementId=${elementid}&amp;amp;partId={$partId}&amp;amp;partNumber={$partNumber}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>Finally, select an icon for the extension. This will appear on the tab that opens the right element panel.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>You have now defined the extension, and it will appear in the Onshape
interface.&lt;/p>
&lt;h3 id="call-a-page-in-the-extension">Call a page in the extension&lt;/h3>
&lt;p>The following code snippet shows how to use your previous definition to
pull data from the third-party application and send it to the web page:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">//https://myserver.com/bom?documentId=${documentId}&amp;amp;elementId=${elementId}&amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">//partId=${partId}&amp;amp;partNumber=${partNumber}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#aaa;font-style:italic">&lt;/span>app.get(&lt;span style="color:#a50">&amp;#39;/bom&amp;#39;&lt;/span>, (req, res) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a">if&lt;/span> (req.query.partNumber !== &lt;span style="color:#a50">&amp;#39;${partNumber&amp;#39;&lt;/span>}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> partController.getPartsList(req.query.partNumber).then((parts) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> catController.getCatById(parts.Category).then((cat) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.render(&lt;span style="color:#a50">&amp;#39;bomview&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parts: parts,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cat: cat
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#00a">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.render(&lt;span style="color:#a50">&amp;#39;bomview&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parts: { &lt;span style="color:#a50">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#099">0&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cat: { &lt;span style="color:#a50">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#099">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This code checks to see if the &lt;code>partNumber&lt;/code> parameter was actually populated (i.e., that a part number was defined for the selected part). If defined, you can use the part number to
retrieve information about the selected part from our third-party application.&lt;/p>
&lt;p>If the part number isn’t defined, you can send an alert to the web page to notify the user that a part number must be defined to use this web page.&lt;/p>
&lt;p>You can also use the document ID, the element ID, and the Part ID to retrieve the correct part as long as they are stored with the part in your application.&lt;/p>
&lt;h3 id="use-the-extension">Use the extension&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>In Onshape, load a document. You will see your icon embedded in
the location you chose for you extension.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Select a part in a Part Studio, and click the icon to open the extension application:
&lt;img src="https://onshape-public.github.io/images/integrationguideimage94.png" style="width:6.5in;height:3.94236in" alt="Graphical user interface Description automatically generated" />&lt;/p>
&lt;p>If the part you selected has not yet been synced with your third-party application, no part number has been generated, and the system can’t find a corresponding object in our database.&lt;/p>
&lt;p>When you select a part that has been synced, and a part number has been generated, you will see the expected result:&lt;/p>
&lt;img src="https://onshape-public.github.io/images/integrationguideimage95.png" style="width:5.49548in;height:3.32019in" alt="Graphical user interface Description automatically generated" />
&lt;p>Since the context you selected for this application extension was &lt;code>Selected Part&lt;/code>, a part must be selected to load anything in the extension. If no part is selected, you will see a notification similar to the following:&lt;/p>
&lt;img src="https://onshape-public.github.io/images/integrationguideimage96.png" style="width:5.10442in;height:1.41408in" alt="Graphical user interface, text, application Description automatically generated" />&lt;/li>
&lt;/ol></description></item></channel></rss>